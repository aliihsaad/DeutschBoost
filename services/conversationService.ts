import { supabase } from '../src/lib/supabase';
import { ai } from './geminiService';
import { CEFRLevel } from '../types';
import { Transcript } from '../types';

/**
 * Interface for conversation feedback generated by AI
 */
export interface ConversationFeedback {
  overall_score: number; // 0-100
  strengths: string[];
  areas_for_improvement: string[];
  grammar_corrections: Array<{
    original: string;
    corrected: string;
    explanation: string;
  }>;
  vocabulary_suggestions: string[];
  fluency_notes: string;
  encouragement: string;
}

/**
 * Start a new conversation session and save it to the database
 * Returns the session ID to be used for updates
 */
export const startConversationSession = async (
  userId: string
): Promise<{ sessionId: string | null; error: Error | null }> => {
  try {
    const { data, error } = await supabase
      .from('conversation_sessions')
      .insert({
        user_id: userId,
        transcript: [],
        started_at: new Date().toISOString(),
      })
      .select('id')
      .single();

    if (error) {
      console.error('Error starting conversation session:', error);
      return { sessionId: null, error };
    }

    return { sessionId: data.id, error: null };
  } catch (err) {
    console.error('Unexpected error starting conversation session:', err);
    return { sessionId: null, error: err as Error };
  }
};

/**
 * Helper function to get localized fallback messages
 */
const getLocalizedFallbackMessages = (motherLanguage: string, type: 'empty' | 'short') => {
  const messages = {
    empty: {
      English: {
        areas_for_improvement: ['No conversation data to analyze'],
        fluency_notes: 'No conversation data available',
        encouragement: 'Start practicing to get feedback!',
      },
      Arabic: {
        areas_for_improvement: ['لا توجد بيانات محادثة للتحليل'],
        fluency_notes: 'لا توجد بيانات محادثة متاحة',
        encouragement: 'ابدأ الممارسة للحصول على التعليقات!',
      },
    },
    short: {
      English: {
        strengths: ['You started a conversation - great first step!'],
        areas_for_improvement: ['Try to have a longer conversation next time'],
        fluency_notes: 'This conversation was too short to provide detailed feedback. Try speaking for at least 2-3 minutes and engaging in meaningful exchanges.',
        encouragement: 'Keep practicing! The more you speak, the better feedback I can give you. Try to have a real conversation with complete sentences next time.',
      },
      Arabic: {
        strengths: ['لقد بدأت محادثة - خطوة أولى رائعة!'],
        areas_for_improvement: ['حاول إجراء محادثة أطول في المرة القادمة'],
        fluency_notes: 'كانت هذه المحادثة قصيرة جدًا لتقديم ملاحظات تفصيلية. حاول التحدث لمدة 2-3 دقائق على الأقل والانخراط في تبادلات ذات مغزى.',
        encouragement: 'استمر في الممارسة! كلما تحدثت أكثر، كلما تمكنت من تقديم ملاحظات أفضل لك. حاول إجراء محادثة حقيقية بجمل كاملة في المرة القادمة.',
      },
    },
  };

  // Return the requested type for the mother language, fallback to English if language not found
  return messages[type][motherLanguage as keyof typeof messages[typeof type]] || messages[type].English;
};

/**
 * Generate AI feedback for a conversation based on transcript and user level
 */
export const generateConversationFeedback = async (
  transcripts: Transcript[],
  userLevel: CEFRLevel,
  motherLanguage: string = 'English'
): Promise<{ feedback: ConversationFeedback | null; error: Error | null }> => {
  try {
    // Filter out empty transcripts and format for AI
    const conversationText = transcripts
      .filter(t => t.text.trim().length > 0)
      .map(t => `${t.speaker === 'user' ? 'Student' : 'Tutor'}: ${t.text}`)
      .join('\n');

    if (conversationText.length === 0) {
      const emptyMessages = getLocalizedFallbackMessages(motherLanguage, 'empty');
      return {
        feedback: {
          overall_score: 0,
          strengths: [],
          areas_for_improvement: emptyMessages.areas_for_improvement,
          grammar_corrections: [],
          vocabulary_suggestions: [],
          fluency_notes: emptyMessages.fluency_notes,
          encouragement: emptyMessages.encouragement,
        },
        error: null,
      };
    }

    // Validate conversation quality - must have meaningful exchanges
    const userMessages = transcripts.filter(t => t.speaker === 'user' && t.text.trim().length > 0);
    const modelMessages = transcripts.filter(t => t.speaker === 'model' && t.text.trim().length > 0);

    // Count meaningful user messages (more than just single words like "ja", "nein", "hallo")
    const meaningfulUserMessages = userMessages.filter(t => {
      const words = t.text.trim().split(/\s+/);
      return words.length >= 2 || t.text.trim().length > 15; // At least 2 words or 15+ characters
    });

    // Need at least 3 meaningful exchanges from the user AND 3 responses from the model
    const MIN_USER_EXCHANGES = 3;
    const MIN_MODEL_EXCHANGES = 3;

    if (meaningfulUserMessages.length < MIN_USER_EXCHANGES || modelMessages.length < MIN_MODEL_EXCHANGES) {
      const shortMessages = getLocalizedFallbackMessages(motherLanguage, 'short');
      return {
        feedback: {
          overall_score: 0,
          strengths: shortMessages.strengths,
          areas_for_improvement: shortMessages.areas_for_improvement,
          grammar_corrections: [],
          vocabulary_suggestions: [],
          fluency_notes: shortMessages.fluency_notes,
          encouragement: shortMessages.encouragement,
        },
        error: null,
      };
    }

    const prompt = `You are an experienced German language teacher evaluating a conversation practice session.

STUDENT LEVEL: ${userLevel} (CEFR scale)
STUDENT'S NATIVE LANGUAGE: ${motherLanguage}

CONVERSATION TRANSCRIPT:
${conversationText}

Analyze this German conversation and provide detailed feedback. Evaluate the student's performance based on ${userLevel} level expectations.

IMPORTANT: ALL feedback must be written in ${motherLanguage}. Every field (strengths, areas_for_improvement, grammar_corrections explanations, fluency_notes, encouragement) must be in ${motherLanguage}, except for German text examples which should remain in German.

Return a JSON object with the following structure:
{
  "overall_score": <number 0-100>,
  "strengths": [<list 3-5 positive observations about the student's German>],
  "areas_for_improvement": [<list 2-4 specific areas to work on>],
  "grammar_corrections": [
    {
      "original": "<incorrect phrase from conversation>",
      "corrected": "<correct version>",
      "explanation": "<why this is the correct form>"
    }
  ],
  "vocabulary_suggestions": [<3-5 useful words or phrases they could have used>],
  "fluency_notes": "<commentary on their speaking fluency, confidence, and naturalness>",
  "encouragement": "<personalized encouraging message acknowledging their level and progress>"
}

Be constructive, specific, and encouraging. Focus on practical improvements.`;

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-pro',
      contents: prompt,
      config: {
        responseMimeType: 'application/json',
        temperature: 0.7,
      },
    });

    const feedbackData = JSON.parse(response.text) as ConversationFeedback;
    return { feedback: feedbackData, error: null };
  } catch (err) {
    console.error('Error generating conversation feedback:', err);
    return { feedback: null, error: err as Error };
  }
};

/**
 * End a conversation session and save transcript, duration, and feedback
 */
export const endConversationSession = async (
  sessionId: string,
  transcripts: Transcript[],
  startTime: Date,
  userLevel: CEFRLevel,
  motherLanguage: string = 'English'
): Promise<{ error: Error | null }> => {
  try {
    const endTime = new Date();
    const durationSeconds = Math.floor((endTime.getTime() - startTime.getTime()) / 1000);

    // Generate AI feedback
    const { feedback, error: feedbackError } = await generateConversationFeedback(
      transcripts,
      userLevel,
      motherLanguage
    );

    if (feedbackError) {
      console.error('Error generating feedback, will save session without it:', feedbackError);
    }

    // Convert transcripts to JSONB format
    const transcriptData = transcripts.map(t => ({
      speaker: t.speaker,
      text: t.text,
      timestamp: t.id,
    }));

    // Update the session with all data
    const { error } = await supabase
      .from('conversation_sessions')
      .update({
        transcript: transcriptData,
        duration_seconds: durationSeconds,
        feedback: feedback ? JSON.stringify(feedback) : null,
        ended_at: endTime.toISOString(),
      })
      .eq('id', sessionId);

    if (error) {
      console.error('Error ending conversation session:', error);
      return { error };
    }

    return { error: null };
  } catch (err) {
    console.error('Unexpected error ending conversation session:', err);
    return { error: err as Error };
  }
};

/**
 * Load past conversation sessions for a user
 */
export const loadConversationHistory = async (
  userId: string,
  limit: number = 10
): Promise<{ sessions: any[] | null; error: Error | null }> => {
  try {
    const { data, error } = await supabase
      .from('conversation_sessions')
      .select('*')
      .eq('user_id', userId)
      .order('started_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error loading conversation history:', error);
      return { sessions: null, error };
    }

    return { sessions: data, error: null };
  } catch (err) {
    console.error('Unexpected error loading conversation history:', err);
    return { sessions: null, error: err as Error };
  }
};

/**
 * Get the most recent conversation feedback for a user
 * Used to provide AI context for personalized conversations
 */
export const getLastConversationFeedback = async (
  userId: string
): Promise<{ feedback: ConversationFeedback | null; error: Error | null }> => {
  try {
    const { data, error } = await supabase
      .from('conversation_sessions')
      .select('feedback, ended_at')
      .eq('user_id', userId)
      .not('feedback', 'is', null)
      .order('ended_at', { ascending: false })
      .limit(1)
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        // No rows returned - user doesn't have any past conversations with feedback
        return { feedback: null, error: null };
      }
      console.error('Error loading last conversation feedback:', error);
      return { feedback: null, error };
    }

    if (!data || !data.feedback) {
      return { feedback: null, error: null };
    }

    // Parse the feedback JSON string
    const feedbackData = typeof data.feedback === 'string'
      ? JSON.parse(data.feedback)
      : data.feedback;

    return { feedback: feedbackData as ConversationFeedback, error: null };
  } catch (err) {
    console.error('Unexpected error loading last conversation feedback:', err);
    return { feedback: null, error: err as Error };
  }
};
