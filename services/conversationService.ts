import { supabase } from '../src/lib/supabase';
import { ai } from './geminiService';
import { CEFRLevel } from '../types';
import { Transcript } from '../types';

/**
 * Interface for conversation feedback generated by AI
 */
export interface ConversationFeedback {
  overall_score: number; // 0-100
  strengths: string[];
  areas_for_improvement: string[];
  grammar_corrections: Array<{
    original: string;
    corrected: string;
    explanation: string;
  }>;
  vocabulary_suggestions: string[];
  fluency_notes: string;
  encouragement: string;
}

/**
 * Start a new conversation session and save it to the database
 * Returns the session ID to be used for updates
 */
export const startConversationSession = async (
  userId: string
): Promise<{ sessionId: string | null; error: Error | null }> => {
  try {
    const { data, error } = await supabase
      .from('conversation_sessions')
      .insert({
        user_id: userId,
        transcript: [],
        started_at: new Date().toISOString(),
      })
      .select('id')
      .single();

    if (error) {
      console.error('Error starting conversation session:', error);
      return { sessionId: null, error };
    }

    return { sessionId: data.id, error: null };
  } catch (err) {
    console.error('Unexpected error starting conversation session:', err);
    return { sessionId: null, error: err as Error };
  }
};

/**
 * Generate AI feedback for a conversation based on transcript and user level
 */
export const generateConversationFeedback = async (
  transcripts: Transcript[],
  userLevel: CEFRLevel,
  motherLanguage: string = 'English'
): Promise<{ feedback: ConversationFeedback | null; error: Error | null }> => {
  try {
    // Filter out empty transcripts and format for AI
    const conversationText = transcripts
      .filter(t => t.text.trim().length > 0)
      .map(t => `${t.speaker === 'user' ? 'Student' : 'Tutor'}: ${t.text}`)
      .join('\n');

    if (conversationText.length === 0) {
      return {
        feedback: {
          overall_score: 0,
          strengths: [],
          areas_for_improvement: ['No conversation data to analyze'],
          grammar_corrections: [],
          vocabulary_suggestions: [],
          fluency_notes: 'No conversation data available',
          encouragement: 'Start practicing to get feedback!',
        },
        error: null,
      };
    }

    const prompt = `You are an experienced German language teacher evaluating a conversation practice session.

STUDENT LEVEL: ${userLevel} (CEFR scale)
STUDENT'S NATIVE LANGUAGE: ${motherLanguage}

CONVERSATION TRANSCRIPT:
${conversationText}

Analyze this German conversation and provide detailed feedback. Evaluate the student's performance based on ${userLevel} level expectations.

Provide your feedback in ${motherLanguage} language (except for German examples which should stay in German).

Return a JSON object with the following structure:
{
  "overall_score": <number 0-100>,
  "strengths": [<list 3-5 positive observations about the student's German>],
  "areas_for_improvement": [<list 2-4 specific areas to work on>],
  "grammar_corrections": [
    {
      "original": "<incorrect phrase from conversation>",
      "corrected": "<correct version>",
      "explanation": "<why this is the correct form>"
    }
  ],
  "vocabulary_suggestions": [<3-5 useful words or phrases they could have used>],
  "fluency_notes": "<commentary on their speaking fluency, confidence, and naturalness>",
  "encouragement": "<personalized encouraging message acknowledging their level and progress>"
}

Be constructive, specific, and encouraging. Focus on practical improvements.`;

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-pro',
      contents: prompt,
      config: {
        responseMimeType: 'application/json',
        temperature: 0.7,
      },
    });

    const feedbackData = JSON.parse(response.text) as ConversationFeedback;
    return { feedback: feedbackData, error: null };
  } catch (err) {
    console.error('Error generating conversation feedback:', err);
    return { feedback: null, error: err as Error };
  }
};

/**
 * End a conversation session and save transcript, duration, and feedback
 */
export const endConversationSession = async (
  sessionId: string,
  transcripts: Transcript[],
  startTime: Date,
  userLevel: CEFRLevel,
  motherLanguage: string = 'English'
): Promise<{ error: Error | null }> => {
  try {
    const endTime = new Date();
    const durationSeconds = Math.floor((endTime.getTime() - startTime.getTime()) / 1000);

    // Generate AI feedback
    const { feedback, error: feedbackError } = await generateConversationFeedback(
      transcripts,
      userLevel,
      motherLanguage
    );

    if (feedbackError) {
      console.error('Error generating feedback, will save session without it:', feedbackError);
    }

    // Convert transcripts to JSONB format
    const transcriptData = transcripts.map(t => ({
      speaker: t.speaker,
      text: t.text,
      timestamp: t.id,
    }));

    // Update the session with all data
    const { error } = await supabase
      .from('conversation_sessions')
      .update({
        transcript: transcriptData,
        duration_seconds: durationSeconds,
        feedback: feedback ? JSON.stringify(feedback) : null,
        ended_at: endTime.toISOString(),
      })
      .eq('id', sessionId);

    if (error) {
      console.error('Error ending conversation session:', error);
      return { error };
    }

    return { error: null };
  } catch (err) {
    console.error('Unexpected error ending conversation session:', err);
    return { error: err as Error };
  }
};

/**
 * Load past conversation sessions for a user
 */
export const loadConversationHistory = async (
  userId: string,
  limit: number = 10
): Promise<{ sessions: any[] | null; error: Error | null }> => {
  try {
    const { data, error } = await supabase
      .from('conversation_sessions')
      .select('*')
      .eq('user_id', userId)
      .order('started_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error loading conversation history:', error);
      return { sessions: null, error };
    }

    return { sessions: data, error: null };
  } catch (err) {
    console.error('Unexpected error loading conversation history:', err);
    return { sessions: null, error: err as Error };
  }
};

/**
 * Get the most recent conversation feedback for a user
 * Used to provide AI context for personalized conversations
 */
export const getLastConversationFeedback = async (
  userId: string
): Promise<{ feedback: ConversationFeedback | null; error: Error | null }> => {
  try {
    const { data, error } = await supabase
      .from('conversation_sessions')
      .select('feedback, ended_at')
      .eq('user_id', userId)
      .not('feedback', 'is', null)
      .order('ended_at', { ascending: false })
      .limit(1)
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        // No rows returned - user doesn't have any past conversations with feedback
        return { feedback: null, error: null };
      }
      console.error('Error loading last conversation feedback:', error);
      return { feedback: null, error };
    }

    if (!data || !data.feedback) {
      return { feedback: null, error: null };
    }

    // Parse the feedback JSON string
    const feedbackData = typeof data.feedback === 'string'
      ? JSON.parse(data.feedback)
      : data.feedback;

    return { feedback: feedbackData as ConversationFeedback, error: null };
  } catch (err) {
    console.error('Unexpected error loading last conversation feedback:', err);
    return { feedback: null, error: err as Error };
  }
};
